# TypeScript & Node.js — 10xRules Cursor Rules
# Premium rules for production-grade TypeScript/Node.js backends

## Project Structure

- Use this layout for backend services:
  ```
  src/
  ├── index.ts              # Entry point, server bootstrap
  ├── config/               # Environment config with validation
  ├── routes/               # Route definitions (Express/Fastify/Hono)
  ├── controllers/          # Request/response handling
  ├── services/             # Business logic
  ├── repositories/         # Data access layer
  ├── middleware/            # Auth, logging, error handling
  ├── types/                # Shared type definitions
  ├── utils/                # Pure utility functions
  └── __tests__/            # Test files mirroring src structure
  ```
- Use `src/` directory with compiled output to `dist/`. Never run TypeScript files directly in production.
- Use path aliases (`@/services/user`) via `tsconfig.json` paths + `tsconfig-paths` or bundler resolution.

## TypeScript Configuration

- Use strict mode. Always. No exceptions:
  ```json
  {
    "compilerOptions": {
      "strict": true,
      "noUncheckedIndexedAccess": true,
      "noImplicitReturns": true,
      "noFallthroughCasesInSwitch": true,
      "exactOptionalPropertyTypes": true,
      "forceConsistentCasingInFileNames": true
    }
  }
  ```
- Target `ES2022` or later for Node.js 18+. Use `"module": "NodeNext"` for ESM.
- Use ESM (`"type": "module"` in package.json) for new projects. Include `.js` extensions in imports.

## Type Patterns

- Never use `any`. Use `unknown` and narrow:
  ```typescript
  function processInput(input: unknown): string {
    if (typeof input === 'string') return input;
    if (input instanceof Error) return input.message;
    return String(input);
  }
  ```
- Use branded types for domain identifiers:
  ```typescript
  type UserId = string & { readonly __brand: 'UserId' };
  type OrderId = string & { readonly __brand: 'OrderId' };
  
  function createUserId(id: string): UserId {
    // validate
    return id as UserId;
  }
  ```
- Use discriminated unions for state machines:
  ```typescript
  type AsyncState<T> =
    | { status: 'idle' }
    | { status: 'loading' }
    | { status: 'success'; data: T }
    | { status: 'error'; error: Error };
  ```
- Use `satisfies` for configuration objects:
  ```typescript
  const routes = {
    home: '/',
    user: '/user/:id',
  } satisfies Record<string, string>;
  ```
- Use `as const` for literal types and `readonly` for immutable data.
- Prefer interfaces for object shapes that may be extended. Use types for unions, intersections, and mapped types.

## Error Handling

- Define a custom error hierarchy:
  ```typescript
  class AppError extends Error {
    constructor(
      message: string,
      public readonly code: string,
      public readonly statusCode: number = 500,
      public readonly isOperational: boolean = true,
    ) {
      super(message);
      this.name = this.constructor.name;
    }
  }
  
  class NotFoundError extends AppError {
    constructor(resource: string, id: string) {
      super(`${resource} not found: ${id}`, 'NOT_FOUND', 404);
    }
  }
  
  class ValidationError extends AppError {
    constructor(message: string) {
      super(message, 'VALIDATION_ERROR', 400);
    }
  }
  ```
- Use Result types for operations that can fail predictably:
  ```typescript
  type Result<T, E = Error> =
    | { ok: true; value: T }
    | { ok: false; error: E };
  ```
- Centralize error handling in middleware. Route handlers should throw, middleware should catch.
- Always handle promise rejections. Use a global `unhandledRejection` handler as a safety net.
- Log errors with structured logging (pino, winston). Never use `console.log` in production.

## Validation

- Use `zod` for ALL external input validation:
  ```typescript
  import { z } from 'zod';
  
  const CreateUserSchema = z.object({
    email: z.string().email(),
    name: z.string().min(1).max(100),
    age: z.number().int().positive().optional(),
  });
  
  type CreateUserInput = z.infer<typeof CreateUserSchema>;
  ```
- Validate at the boundary: API inputs, environment variables, config files, external API responses.
- Use `z.infer<>` to derive TypeScript types from schemas. Single source of truth.
- Never trust external data. Always validate AND sanitize.

## Async Patterns

- Always use `async/await`. Never use raw `.then()` chains.
- Use `Promise.all()` for independent concurrent operations:
  ```typescript
  const [user, orders] = await Promise.all([
    userService.getById(id),
    orderService.getByUserId(id),
  ]);
  ```
- Use `Promise.allSettled()` when partial failure is acceptable.
- Never use `Promise.all()` for operations that should be sequential (e.g., ordered writes).
- Implement proper cleanup with `AbortController` for cancellable operations.
- Use `AsyncLocalStorage` for request-scoped context (logging correlation IDs).

## Database Access

- Use a repository pattern to isolate database queries from business logic.
- Use parameterized queries. NEVER interpolate user input into SQL strings.
- Use connection pooling. Never create a new connection per request.
- Use transactions for multi-step mutations:
  ```typescript
  async function transferFunds(from: AccountId, to: AccountId, amount: number): Promise<Result<void>> {
    return db.transaction(async (tx) => {
      await tx.update(accounts).set({ balance: sql`balance - ${amount}` }).where(eq(accounts.id, from));
      await tx.update(accounts).set({ balance: sql`balance + ${amount}` }).where(eq(accounts.id, to));
    });
  }
  ```
- Prefer Drizzle ORM or Prisma for type-safe database access.

## API Design

- Use consistent response envelopes:
  ```typescript
  interface ApiResponse<T> {
    success: boolean;
    data?: T;
    error?: { code: string; message: string };
    meta?: { page: number; total: number };
  }
  ```
- Use proper HTTP status codes: 200 OK, 201 Created, 204 No Content, 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found, 409 Conflict, 422 Unprocessable Entity, 500 Internal Server Error.
- Version APIs from day one: `/api/v1/`.
- Use pagination for list endpoints. Support `cursor` (preferred) or `offset/limit`.

## Testing

- Use Vitest for unit and integration tests. It's faster than Jest and natively supports TypeScript.
- Test the service layer thoroughly. Controllers need fewer tests if services are well-tested.
- Use dependency injection to make services testable:
  ```typescript
  class UserService {
    constructor(
      private readonly userRepo: UserRepository,
      private readonly emailService: EmailService,
    ) {}
  }
  ```
- Use `supertest` or direct HTTP client for integration tests.
- Mock at boundaries (database, external APIs), not internal modules.
- Aim for high coverage on business logic, lower on plumbing code.

## Security

- Use `helmet` middleware for HTTP security headers.
- Implement rate limiting on all public endpoints.
- Use `bcrypt` or `argon2` for password hashing. Never SHA-256.
- Validate and sanitize all input. Use allowlists, not denylists.
- Never log sensitive data (passwords, tokens, PII).
- Use `crypto.randomUUID()` for IDs, `crypto.randomBytes()` for tokens.

## Performance

- Use `pino` for logging (fastest Node.js logger).
- Implement graceful shutdown:
  ```typescript
  process.on('SIGTERM', async () => {
    server.close();
    await db.destroy();
    process.exit(0);
  });
  ```
- Use connection pooling for databases and HTTP clients.
- Set appropriate timeouts on all external calls.
- Use `node --max-old-space-size` for memory-intensive workloads.

## Anti-Patterns to NEVER Generate

- Do NOT use `any`. Ever. Use `unknown` and narrow.
- Do NOT use `require()`. Use ESM `import`.
- Do NOT use `var`. Use `const` by default, `let` when reassignment is needed.
- Do NOT use `== ` or `!=`. Always `===` and `!==`.
- Do NOT use `Function`, `Object`, or `String` as types. Use `() => void`, `Record<string, unknown>`, `string`.
- Do NOT throw strings. Always throw `Error` instances.
- Do NOT use `new Date()` for business logic. Use a date library (date-fns, luxon) or `Temporal`.
- Do NOT silence errors with empty catch blocks.
- Do NOT use `process.env.X` directly. Validate with zod at startup.
- Do NOT use callback-style APIs when promise versions exist.
- Do NOT mutate function parameters.
