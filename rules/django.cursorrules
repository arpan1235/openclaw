# Django — 10xRules Cursor Rules
# Premium rules for production-grade Django applications

## Project Structure

- Use this layout for Django projects:
  ```
  project/
  ├── config/                # Project-level configuration
  │   ├── settings/
  │   │   ├── base.py       # Shared settings
  │   │   ├── local.py      # Development overrides
  │   │   ├── production.py # Production overrides
  │   │   └── test.py       # Test overrides
  │   ├── urls.py           # Root URL configuration
  │   ├── wsgi.py
  │   └── asgi.py
  ├── apps/
  │   ├── users/            # Custom user app
  │   ├── core/             # Shared base models, utilities
  │   └── <feature>/        # Feature-specific apps
  ├── templates/            # Project-level templates
  ├── static/               # Project-level static files
  └── manage.py
  ```
- Each app should be self-contained: models, views, urls, serializers, tests, admin.
- App structure:
  ```
  apps/<feature>/
  ├── migrations/
  ├── tests/
  │   ├── test_models.py
  │   ├── test_views.py
  │   └── test_services.py
  ├── admin.py
  ├── apps.py
  ├── forms.py              # Django forms
  ├── models.py
  ├── serializers.py        # DRF serializers
  ├── services.py           # Business logic
  ├── selectors.py          # Complex queries
  ├── urls.py
  └── views.py
  ```

## Models

- Always create a custom User model from day one:
  ```python
  from django.contrib.auth.models import AbstractUser
  
  class User(AbstractUser):
      pass  # Extend later without migrations headaches
  ```
- Use an abstract base model for common fields:
  ```python
  class TimestampedModel(models.Model):
      created_at = models.DateTimeField(auto_now_add=True)
      updated_at = models.DateTimeField(auto_now=True)
      
      class Meta:
          abstract = True
  ```
- Use UUIDs for public-facing IDs, auto-incrementing integers for internal PKs:
  ```python
  class Order(TimestampedModel):
      id = models.BigAutoField(primary_key=True)
      uuid = models.UUIDField(default=uuid.uuid4, unique=True, editable=False, db_index=True)
  ```
- Define `__str__` on every model. Define `Meta.ordering` explicitly.
- Use `choices` with `TextChoices`/`IntegerChoices` enums:
  ```python
  class Status(models.TextChoices):
      DRAFT = "draft", "Draft"
      PUBLISHED = "published", "Published"
      ARCHIVED = "archived", "Archived"
  
  class Article(TimestampedModel):
      status = models.CharField(max_length=20, choices=Status.choices, default=Status.DRAFT)
  ```
- Use `db_index=True` on fields you filter/order by frequently.
- Use `related_name` on all ForeignKey and ManyToMany fields:
  ```python
  author = models.ForeignKey(User, on_delete=models.CASCADE, related_name="articles")
  ```

## QuerySets & Database Access

- NEVER put complex queries in views. Use a selectors module:
  ```python
  # apps/articles/selectors.py
  def get_published_articles(*, author: User | None = None) -> QuerySet[Article]:
      qs = Article.objects.filter(status=Status.PUBLISHED).select_related("author")
      if author:
          qs = qs.filter(author=author)
      return qs.order_by("-published_at")
  ```
- Always use `select_related()` for ForeignKey and `prefetch_related()` for reverse FK / M2M to avoid N+1:
  ```python
  # BAD — N+1 queries
  articles = Article.objects.all()
  for article in articles:
      print(article.author.name)  # Hits DB for each article
  
  # GOOD — 1 query with JOIN
  articles = Article.objects.select_related("author").all()
  ```
- Use `only()` or `defer()` to limit fetched columns for large models.
- Use `F()` expressions for database-level operations:
  ```python
  from django.db.models import F
  Article.objects.filter(id=article_id).update(view_count=F("view_count") + 1)
  ```
- Use `Q()` for complex queries:
  ```python
  from django.db.models import Q
  Article.objects.filter(Q(status="published") | Q(author=request.user))
  ```
- Use `Exists()` and `Subquery()` instead of Python-level filtering.
- Use `bulk_create()` and `bulk_update()` for batch operations. Never loop with `.save()`.

## Business Logic (Services Pattern)

- Keep views thin. Put business logic in services:
  ```python
  # apps/orders/services.py
  from django.db import transaction
  
  def create_order(*, user: User, items: list[dict], shipping_address: str) -> Order:
      """Create an order with items and trigger notifications."""
      with transaction.atomic():
          order = Order.objects.create(
              user=user,
              shipping_address=shipping_address,
              status=OrderStatus.PENDING,
          )
          order_items = [
              OrderItem(order=order, product_id=item["product_id"], quantity=item["quantity"])
              for item in items
          ]
          OrderItem.objects.bulk_create(order_items)
          order.calculate_total()
          order.save(update_fields=["total"])
      
      send_order_confirmation.delay(order.id)  # Async task
      return order
  ```
- Services should accept keyword-only arguments (`*`) for clarity.
- Services handle transactions, validation, and orchestration.
- Views handle HTTP concerns (parsing request, returning response).

## Django REST Framework

- Use serializers for validation and representation:
  ```python
  class ArticleCreateSerializer(serializers.Serializer):
      title = serializers.CharField(max_length=200)
      content = serializers.CharField()
      tags = serializers.ListField(child=serializers.CharField(), required=False)
      
      def validate_title(self, value: str) -> str:
          if Article.objects.filter(title__iexact=value).exists():
              raise serializers.ValidationError("Article with this title already exists.")
          return value
  
  class ArticleResponseSerializer(serializers.ModelSerializer):
      author = UserSerializer(read_only=True)
      
      class Meta:
          model = Article
          fields = ["uuid", "title", "content", "author", "status", "created_at"]
  ```
- Use separate serializers for input (Create/Update) and output (Response). Never use the same for both.
- Use `@api_view` for simple endpoints, `APIView` for complex ones, `ViewSet` for full CRUD:
  ```python
  class ArticleViewSet(viewsets.ModelViewSet):
      serializer_class = ArticleResponseSerializer
      permission_classes = [IsAuthenticated]
      lookup_field = "uuid"
      
      def get_queryset(self):
          return get_published_articles(author=self.request.user)
      
      def perform_create(self, serializer):
          create_article(
              user=self.request.user,
              **serializer.validated_data,
          )
  ```
- Always use pagination:
  ```python
  REST_FRAMEWORK = {
      "DEFAULT_PAGINATION_CLASS": "rest_framework.pagination.CursorPagination",
      "PAGE_SIZE": 20,
  }
  ```
- Use throttling on public endpoints.

## Security

- Always use `@login_required` or `IsAuthenticated` permission on protected views.
- Use Django's CSRF protection. Never disable it.
- Use `get_object_or_404` to avoid leaking information about object existence.
- Always use parameterized queries. Never construct raw SQL with string formatting.
- Set security headers in production:
  ```python
  SECURE_BROWSER_XSS_FILTER = True
  SECURE_CONTENT_TYPE_NOSNIFF = True
  SECURE_SSL_REDIRECT = True
  SESSION_COOKIE_SECURE = True
  CSRF_COOKIE_SECURE = True
  SECURE_HSTS_SECONDS = 31536000
  ```
- Use `django-cors-headers` with explicit allowed origins in production.

## Settings

- Use environment variables for secrets and configuration:
  ```python
  # config/settings/base.py
  import environ
  
  env = environ.Env()
  
  SECRET_KEY = env("DJANGO_SECRET_KEY")
  DEBUG = env.bool("DJANGO_DEBUG", default=False)
  DATABASES = {"default": env.db("DATABASE_URL")}
  ```
- Never commit `.env` files or secrets to version control.
- Use `django-environ` for clean environment variable parsing.
- Split settings into base/local/production/test files.

## Testing

- Use `pytest-django` with fixtures:
  ```python
  import pytest
  from apps.articles.services import create_article
  
  @pytest.fixture
  def user(db):
      return User.objects.create_user(email="test@example.com", password="testpass123")
  
  @pytest.fixture
  def article(user):
      return create_article(user=user, title="Test Article", content="Content")
  
  class TestCreateArticle:
      def test_creates_article(self, user):
          article = create_article(user=user, title="New", content="Body")
          assert article.title == "New"
          assert article.author == user
      
      def test_rejects_duplicate_title(self, article, user):
          with pytest.raises(ValidationError):
              create_article(user=user, title=article.title, content="Other")
  ```
- Use `factory_boy` for complex test data:
  ```python
  class UserFactory(factory.django.DjangoModelFactory):
      class Meta:
          model = User
      email = factory.Sequence(lambda n: f"user{n}@example.com")
      name = factory.Faker("name")
  ```
- Use `@pytest.mark.django_db` for tests that need database access.
- Test services directly. Test views via API client. Test models for custom methods and constraints.

## Migrations

- Always review auto-generated migrations before committing.
- Use `RunPython` for data migrations. Never modify data in schema migrations.
- Name migrations descriptively: `0003_add_article_published_at.py`, not `0003_auto_20240101.py`.
- Add `db_index` for fields used in `filter()`, `order_by()`, `distinct()`.
- For large tables, use `AddIndex` concurrently on PostgreSQL.

## Celery / Background Tasks

- Define tasks in `tasks.py` within each app:
  ```python
  from celery import shared_task
  
  @shared_task(bind=True, max_retries=3, default_retry_delay=60)
  def send_order_confirmation(self, order_id: int) -> None:
      try:
          order = Order.objects.get(id=order_id)
          send_email(order.user.email, "Order Confirmation", ...)
      except Order.DoesNotExist:
          return  # Order was deleted, skip
      except EmailError as exc:
          raise self.retry(exc=exc)
  ```
- Always pass IDs to tasks, not model instances (they're not serializable).
- Set `max_retries` and `default_retry_delay` on all tasks.
- Use `transaction.on_commit()` to schedule tasks after the transaction succeeds.

## Anti-Patterns to NEVER Generate

- Do NOT put business logic in views, serializers, or models. Use services.
- Do NOT use `Model.objects.all()` without pagination in views.
- Do NOT use `filter()` in loops (N+1 queries). Use `select_related`/`prefetch_related`.
- Do NOT use `CharField` without `max_length`.
- Do NOT use `null=True` on string fields. Use `blank=True, default=""`.
- Do NOT use `ForeignKey` without specifying `on_delete`.
- Do NOT use `print()` for debugging. Use `logging` module.
- Do NOT import settings with `from config.settings.base import *`. Use `django.conf.settings`.
- Do NOT use raw SQL unless absolutely necessary. Use the ORM.
- Do NOT use synchronous views for I/O-heavy operations in ASGI mode.
